<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>实验2</title>
    <script src="js/three.js"></script>
    <script src="js/EffectComposer.js"></script>
    <script src="js/CopyShader.js"></script>
    <script src="js/RenderPass.js"></script>
    <script src="js/TexturePass.js"></script>
    <script src="js/ShaderPass.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/DRACOLoader.js"></script>
    <script type="x-shader/x-vertex" id="vertexshader_01">
        varying vec3 vNormal; //out
        varying vec2 vUv;
        varying vec3 vPos; 
        varying vec3 fragPos;
        void main() { 
            vNormal = mat3(transpose(inverse(modelMatrix))) * normal; //修复不等比缩放，inverse逆矩阵开销巨大
            vUv = uv; 
            vPos = position;
            fragPos = vec3(modelMatrix * vec4(vPos, 1.0));
            gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vPos, 1.0);// 好像连顺序都不能乱
        }
    </script>
    <style type="text/css">
        div#canvas-frame {
            border: none;
            cursor: pointer;
            width: 100%;
            height: 600px;
            background-color: #eeeeee;
        }
        
        .contain {
            display: flex;
            justify-content: space-around;
            margin-top: 40px;
            overflow: auto;
        }
        
        .instruct {
            background-color: #dffaf0ce;
            padding: 0 20px;
            width: 300px;
            text-align: center;
            line-height: 40px;
        }
        
        body {
            margin: 0;
            background-color: #a8f0ecce;
        }
    </style>
</head>

<body>
    <div class="contain">
        <div class="instruct">
            <h2>操作说明</h2>
            <span>鼠标拖动以旋转:<br>数字键1:默认<br>数字键2:纯白<br>数字键3:Rainbow<br>数字键4:木箱<br>数字键5:没做</span>
        </div>
        <div id="wrap"></div>
    </div>
</body>
<script>
    var container
    var camera, scene, renderer
    var orbitControls
    var daytime = true
    const clock = new THREE.Clock();
    
    //摄像机设置
    scene = new THREE.Scene()
    camera = new THREE.PerspectiveCamera(60, 600 / 600, 1, 10000)//视场角度，宽高比，近平面距离，远平面距离
    camera.position.set(5, 2, 8)//摄像机位置
    //camera.lookAt(new THREE.Vector3(0, 0, 0))//摄像机朝向

    //renderer设置
    renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        precision: "highp",
        depth: true,
    })
    renderer.setClearColor(new THREE.Color(0x66ccff))//清屏颜色,16进制值
    renderer.setSize(640, 640)//渲染窗口大小
    renderer.setPixelRatio(window.devicePixelRatio * 1.2)//1.52倍分辨率渲染，之后下采样
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.VSMShadowMap; // default THREE.PCFShadowMap THREE.PCFSoftShadowMap THREE.VSMShadowMap
    container = document.getElementById('wrap')
    container.appendChild(renderer.domElement)

    //控制设置
    orbitControls = new THREE.OrbitControls(camera, renderer.domElement)
    orbitControls.target.set(0.0,0.5,0.0)
    orbitControls.update()
    orbitControls.enableDamping = true
    //光照设置，添加光源
    scene.add( new THREE.HemisphereLight( 0xffffff, 0x000000, 0.1 ) );
    const dirLight = new THREE.DirectionalLight( 0xffffff, 1.0 );
    dirLight.position.set( 10, 0, 10 );
    dirLight.castShadow = true;
    scene.add( dirLight );
    dirLight.shadow.mapSize.width =1024; // default
    dirLight.shadow.mapSize.height =1024; // default
    dirLight.shadow.camera.near = 0.1; // default
    dirLight.shadow.camera.far = 500; // default
    dirLight.shadow.bias = -0.001
    var shadowHelper = new THREE.CameraHelper( dirLight.shadow.camera );
    scene.add( shadowHelper );
    

    //后期处理(post-processing)设置
    
    //自定义Shader
    var dayShader = {
        uniforms: {
        "tDiffuse": { value: null },
        "powRGB": { value: new THREE.Vector3(2.0,1.8,1.4) },
        "mulRGB": { value: new THREE.Vector3(2.0,1.8,1.4) },
        "addRGB": { value: new THREE.Vector3(0.1,0.05,0.0)}//偏移量
        },
        vertexShader: [document.getElementById('vertexshader_01').textContent].join( "\n" ),
        fragmentShader: [
		"uniform sampler2D tDiffuse;",
		"uniform vec3 powRGB;",
		"uniform vec3 mulRGB;",
		"uniform vec3 addRGB;",
		"varying vec2 vUv;",
		"void main() {",
		"gl_FragColor = texture2D( tDiffuse, vUv );",
		"gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );",
		"}"
	    ].join( "\n" )
    };
    var nightShader = {
        uniforms: {
        "tDiffuse": { value: null },
        "powRGB": { value: new THREE.Vector3(2.0,2.0,2.0) },
        "mulRGB": { value: new THREE.Vector3(1.0,1.0,1.0) },
        "addRGB": { value: new THREE.Vector3(0.0,0.0,0.1)}//偏移量
        },
        vertexShader: [document.getElementById('vertexshader_01').textContent].join( "\n" ),
        fragmentShader: [
		"uniform sampler2D tDiffuse;",
		"uniform vec3 powRGB;",
		"uniform vec3 mulRGB;",
		"uniform vec3 addRGB;",
		"varying vec2 vUv;",
		"void main() {",
		"gl_FragColor = texture2D( tDiffuse, vUv );",
		"gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );",
		"}"
	    ].join( "\n" )
    };
    var gammaCorr = {
        uniforms: {
            "tDiffuse": { value: null },
            "gamma":{value: 2.2}
        },
        vertexShader: [document.getElementById('vertexshader_01').textContent].join( "\n" ),
        fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform float gamma;",
        "varying vec2 vUv;",
        "void main() {",
        "vec4 tex = texture2D( tDiffuse, vUv );",
        "gl_FragColor = vec4(pow(tex.rgb,vec3(1.0/gamma)),1.0);",
        "}"
        ].join( "\n" )
    }
    var brightnessContrast = {
        uniforms: {
            "tDiffuse": { value: null },
            "brightness": { value: 0.1 },
            "contrast": { value: -0.2 }
        },
        vertexShader: [document.getElementById('vertexshader_01').textContent].join( "\n" ),
        fragmentShader: [
            "uniform sampler2D tDiffuse;",
            "uniform float brightness;",
            "uniform float contrast;",
            "varying vec2 vUv;",
            "void main() {",
            "gl_FragColor = texture2D( tDiffuse, vUv );",
            "gl_FragColor.rgb += brightness;",
            "if (contrast > 0.0) {",
            "gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;",
            "} else {",
            "gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;",
            "}",
            "}"
        ].join( "\n" )
    }
    var filmShader = {
        uniforms: {
        'tDiffuse': { value: null },
        'time': { value: 0.0 },
        'nIntensity': { value: 0.2 },//胶片颗粒强度
        'sIntensity': { value: 0 },//扫描线效果强度
        'sCount': { value: 3072 },//颗粒数
        'grayscale': { value: null }//转灰阶
        },

        vertexShader: [document.getElementById('vertexshader_01').textContent].join( "\n" ),
        fragmentShader: [
            '#include <common>',
            // control parameter
            'uniform float time;',
            'uniform bool grayscale;',
            // noise effect intensity value (0 = no effect, 1 = full effect)
            'uniform float nIntensity;',
            // scanlines effect intensity value (0 = no effect, 1 = full effect)
            'uniform float sIntensity;',
            // scanlines effect count value (0 = no effect, 4096 = full effect)
            'uniform float sCount;',
            'uniform sampler2D tDiffuse;',
            'varying vec2 vUv;',
            'void main() {',
            'vec4 cTextureScreen = texture2D( tDiffuse, vUv );',
            // make some noise
            'float dx = rand( vUv + time );',
            // add noise
            'vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );',
            // get us a sine and cosine
            'vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );',
            // add scanlines
            'cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;',
            // interpolate between source and result by intensity
            'cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );',
            // convert to grayscale if desired
            'if( grayscale ) {',
            'cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );',
            '}',
            'gl_FragColor =  vec4( cResult, cTextureScreen.a );',
            '}'
        ].join( '\n' )
    };
    var dayPass = new THREE.ShaderPass(dayShader)
    var nightPass = new THREE.ShaderPass(nightShader)
    var filmPass = new THREE.ShaderPass(filmShader)
    var gammaPass = new THREE.ShaderPass(gammaCorr)
    var briContrastPass = new THREE.ShaderPass(brightnessContrast)
    var effectCopy = new THREE.ShaderPass(THREE.CopyShader)//复制通道,shader导入自copyshader.js
    var renderPass = new THREE.RenderPass(scene,camera)//场景渲染,类导入自renderpass.js
    
    const composer = new THREE.EffectComposer(renderer)
    composer.addPass(renderPass)//添加场景渲染通道
    composer.addPass(effectCopy)//添加复制通道
    var renderScene = new THREE.TexturePass(composer.renderTarget2)//将初识渲染画面转为一张材质，传递到下一个后期着色器

    const composerDay = new THREE.EffectComposer(renderer)
    composerDay.addPass(renderScene)
    composerDay.addPass(gammaPass)
    composerDay.addPass(briContrastPass)
    composerDay.addPass(dayPass)
    composerDay.addPass(filmPass)
    composerDay.addPass(effectCopy)

    const composerNight =  new THREE.EffectComposer(renderer)
    composerNight.addPass(renderScene)
    composerNight.addPass(gammaPass)
    composerNight.addPass(briContrastPass)
    composerNight.addPass(nightPass)
    composerNight.addPass(filmPass)
    composerNight.addPass(effectCopy)
    
    //加载模型(GLTF&DRACO)
    const dracoLoader = new THREE.DRACOLoader()
    dracoLoader.setDecoderPath('js/draco/gltf')
    let mixer
    const loader = new THREE.GLTFLoader()
    var model
    loader.setDRACOLoader(dracoLoader)
    loader.load('models/tokyo/scene.gltf',function(gltf){
        model = gltf.scene;
        model.position.set(1,1,0);
        model.scale.set(0.01,0.01,0.01)
        model.traverse(function(child){
            if ( child.isMesh ) { 
                child.castShadow = true;
                child.receiveShadow = true;
             }
        })
        console.log("GLTF Loaded");
        scene.add(model)
        mixer = new THREE.AnimationMixer(model)
        mixer.clipAction(gltf.animations[0]).play()
        animate()
        },undefined,function(error){console.error(error)}
    )

    function animate(time) {
        time *= 0.0002
        let cos = Math.cos(time)
        let sin = Math.sin(time)
        requestAnimationFrame( animate );
        var delta = clock.getDelta();
        mixer.update(delta);
        orbitControls.update(delta);
        
        filmPass.uniforms["time"].value = time

        composer.render(delta);
        dirLight.intensity = Math.abs(sin)
        if(sin>0){
            dirLight.position.set( 10 * cos * 0.5, 10 * sin, 10 * cos * 0.5);
            composerDay.render(delta)
        }
        else{
            dirLight.position.set( 10 * cos * 0.5 * -1, 10 * sin * -1, 10 * cos * 0.5 * -1);
            composerNight.render(delta)
        }
        
    }
</script>

</html>